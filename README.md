# گزارش آزمایش هفتم 

## بخش اول: بازآرایی پروژه‌ی MiniJava

### مورد اول: Facade

از آن‌جایی که CodeGenerator تعداد زیادی تابع public و interfaceای پیچیده داشت اما تنها از برخی توابع آن توسط Parser استفاده می‌شد، با افزودن CodeGeneratorFacade سعی کردیم interface بیرونی آن را ساده‌تر کنیم.
بنابراین کلاس facade تنها دو تابع دارد که هر دو توسط parser استفاده می‌شوند و پیچیدگی‌های پیاده‌سازی نیز در آن نیامده است.

### مورد دوم: Facade

کلاس lexicalAnalyzer از دید parser کارکرد بسیار ساده‌ای دارد و تنها باید token بعدی را به او بدهد. اما جزئیات پیاده‌سازی ظاهر این کلاس را پیچیده کرده است بنابراین با افزودن LexicalAnalyzerFacade این جزئیات را از دید parser پنهان کردیم.
در این کلاس تنها تابع getNextToken قرار دارد و پیاده‌سازی آن بسیار ساده است.

### مورد سوم: State

در کلاس CodeGenerator تعداد زیادی switch روی SymbolTypeهای Symbolها قرار داشت که در صورت bool یا int بودن varType متناسب با آن را مشخص می‌کرد. ما سعی کردمی با استفاده از state pattern این switchها را به یک method call تبدیل کنیم. برای این کار  SymbolType را از enum به abstract class تغییر دادیم و به ازای هر نوع آن یک کلاس فرزند برای آن ساختیم و تعیین varType متناسب را به کلاس‌های فرزند سپردیم. با این کار تعداد زیادی از switchهای CodeGenerator از بین رفتند.

### مورد چهارم: Separate Query from Modifier

در کلاس Memory تابع saveMemory عملا دو عملیات متفاوت نگه داشتن یک واحد حافظه برای یک بلوک کد و همچنین برگرداندن آدرس آن بلوک از حافظه را بر عهده دارد. با جدا کردن query از این تابع و افزودن تابع getMemorySize به کلاس Memory، اصل single responsibility را رعایت کردیم.
بنابراین تابع اولیه تنها عمل modify و تابع جدید تنها عمل query را انجام می‌دهد.
این تابع تنها در CodeGenerator استفاده شده بود که تغییرات لازم مربوط به آن را نیز اعمال کردیم.

### مورد پنجم : self encapsulate field
این پترن بیان میکند که برای دسترسی به فیلدهای خصوصی یک کلاس از درون همان کلاس، باید متدهای دسترسی getter و setter تعریف کنیم و مستقیم به آنها دسترسی نداشته باشیم.
بنابراین در کلاس Memory که فیلد های خصوصی زیادی داریم که از درون همین کلاس نیز مستقیم دسترسی گرفته اند این پترن را اعمال کردیم: به این صورت که برای تمامی این فیلد ها getter و setter تعریف کردیم و دسترسی فقط از طریق این متدها به فیلدها صورت میگیرد.

### مورد ششم (پترن دلخواه): encapsulate field
این پترن بیان میکند که فیلد های یک شی نباید به صورت عمومی در معرض دید قرار بگیرد، و در عوض تمام دسترسی ها از خارج از شی باید از طریق مندهای دسترسی getter و setter صورت بگیرد.
درنتیجه فیلد های کلاس Action را private کرده و برای آنها getter و setter تعریف کردیم.

### مورد هفتم (پترن دلخواه): extract method 
این پترن بیان میکند که تکه ای از کد را که قابلیت جداسازی دارد را جدا کرده و به یک متد مجزا تبدیل کنیم و در متد قدیمی این متد را فراخوانی کنیم.
در کلاس ParseTable میبینیم که متد ParseTable طولانی است و وضایف متعددی از قببل پاک سازی براکت ها، جداسازی سطرها، پردازش هدر برای ترمینال ها و غیرترمینال ها و پرکردن جداول goto و action. بنابراین هر کدام از این بخش ها را به متدی خصوصی تبدیل میکنیم.

### مورد هشتم (پترن دلخواه): parameterize method
در این پترن، متد هایی که عملیات یکسانی انجام میدهند و فقط در مثادیر درونی متفاوت هستند را یکی میکند و مقادیر خاص هرکدام را به عنوان پارامتر به این متد جدید پاس میدهد.
در کلاس CodeGenerator سه تابع add, sub, mult داریم که منطق مشابهی دارند. بنابراین متد arithmeticOperation را جایگزین این سه متد کردیم.